#include<stdio.h>
/* 
 * bitOr - 使用仅有的~和&操作符实现x | y
 * 中文题目：仅使用按位非(~)和按位与(&)操作符实现按位或(|)操作
 * 示例：bitOr(6, 5) = 7
 * 允许的操作：~ &
 * 最大操作数：8
 * 难度评级：1
 */

int bitOr(int x, int y) {
	/* 
	 * 利用德摩根定律：~(a & b) = ~a | ~b 的逆运算
	 * x | y = ~(~x & ~y)
	 * 即先对x和y分别取反，再进行按位与，最后再取反得到按位或的结果
	 */
	return ~(~x & ~y);
}

/*
 * bitNor - 使用仅有的~和&操作符实现~(x|y)
 * 中文题目：仅使用按位非(~)和按位与(&)操作符实现按位或非(~|)操作
 * 示例：bitNor(0x6, 0x5) = 0xFFFFFFF8
 * 允许的操作：~ &
 * 最大操作数：8
 * 难度评级：1
 */

int bitNor(int x, int y) {
	/* 
	 * 利用德摩根定律：~(a | b) = ~a & ~b
	 * 直接对x和y分别取反，然后进行按位与操作
	 */
	return (~x) & (~y);
}

/*
 * fitsShort - 判断x是否可以表示为16位的补码整数
 * 中文题目：如果x可以被表示为一个16位的补码整数，则返回1，否则返回0
 * 示例：fitsShort(33000) = 0, fitsShort(-32768) = 1
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：8
 * 难度评级：1
 */

int fitsShort(int x) {
	/* 
	 * 左移16位，丢弃低16位，保留高16位符号位信息
	 */
	int c = x << 16;
	/* 
	 * 再右移16位，如果是算术右移，那么高位会填充符号位
	 * 如果x可以用16位表示，那么右移后应该与原x相等
	 */
	int y = c >> 16;
	/* 
	 * 使用异或操作判断x和y是否相等
	 * 如果x和y相等，x^y=0，!0=1；否则返回0
	 */
	return !(x ^ y);
}

/********************************************************************************/
/*
 * byteNot - 对x中第n个字节进行位反转
 * 中文题目：对32位整数x中的第n个字节进行位反转（按位取反）
 * 字节编号规则：从0（最低有效字节）到3（最高有效字节）
 * 示例：getByteNot(0x12345678,1) = 0x1234A978（对第二个字节0x56取反得到0xA9）
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：6
 * 难度评级：2
 */

int byteNot(int x, int n) {
	/* 
	 * 计算需要左移的位数，因为每个字节占8位，所以n << 3相当于n * 8
	 */
	int shift = n << 3;
	/* 
	 * 创建一个掩码，将0xFF左移shift位，使该掩码只在目标字节位置为全1
	 */
	int mask = 0xFF << shift;
	/* 
	 * 使用异或操作，对目标字节进行位反转
	 * 异或1会反转每一位，异或0保持不变
	 */
	return x ^ mask;
}

/*
 * divpwr2 - 计算x除以2的n次方，向零舍入
 * 中文题目：计算x/(2^n)，要求结果向零舍入（截断小数部分），其中0 <= n <= 30
 * 示例：divpwr2(15,1) = 7, divpwr2(-33,4) = -2
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：15
 * 难度评级：2
 */

int divpwr2(int x, int n) {
	/* 
	 * 获取x的符号位，如果x为负数，sign为全1（-1的补码表示），否则为0
	 */
	int sign = x >> 31;
	/* 
	 * 计算偏置值bias = 2^n - 1
	 * (1 << n) 得到2^n，加上~0（全1）相当于减1
	 */
	int bias = (1 << n) + (~0);
	/* 
	 * 对于负数，需要加上bias进行向上舍入，以实现向零舍入的效果
	 * 对于正数，bias & sign 结果为0，不影响
	 * 最后右移n位实现除以2^n
	 */
	return (x + (bias & sign)) >> n;
}

/*
 * float_abs - 返回浮点参数f的绝对值的位级表示
 * 中文题目：返回单精度浮点数f的绝对值的位级表示
 * 参数和结果都以无符号整数形式传递，但应被解释为单精度浮点数的位级表示
 * 当参数是NaN（不是一个数）时，返回参数本身
 * 允许的操作：任何整数/无符号操作，包括||, &&，以及if, while
 * 最大操作数：10
 * 难度评级：2
 */
unsigned float_abs(unsigned uf) {
	/* 
	 * 清除符号位（第31位）得到绝对值的位表示
	 * 0x7FFFFFFF是符号位为0，其余位为1的掩码
	 */
	unsigned abs_val = uf & 0x7FFFFFFF;
	/* 
	 * 检查是否为NaN：如果指数位全为1且尾数位不全为0，则为NaN
	 * 0x7F800000是指数位全为1，尾数位全为0的值（正无穷）
	 * 所以如果abs_val > 0x7F800000，说明是NaN
	 */
	if (abs_val > 0x7F800000) {
		return uf; // 如果是NaN，返回原始值
	}
	return abs_val; // 否则返回清除符号位后的值
}

/*
 * mul2OK - 判断是否可以计算2*x而不发生溢出
 * 中文题目：判断是否可以安全地计算2*x而不会发生整数溢出
 * 示例：mul2OK(0x30000000) = 1（不会溢出）
 *      mul2OK(0x40000000) = 0（会溢出）
 * 允许的操作：~ & ^ | + << >>
 * 最大操作数：20
 * 难度评级：2
 */

int mul2OK(int x) {
	/* 
	 * 获取x的符号位（最高位）
	 */
	int h1 = (x >> 31) & 0x1;
	/* 
	 * 将x左移一位（相当于乘以2），然后获取新的符号位
	 */
	int h2 = ((x << 1) >> 31) & 0x1;
	/* 
	 * 如果x乘以2后符号位发生变化，说明发生了溢出
	 * 使用异或判断h1和h2是否相同，再取反得到是否无溢出
	 * 最后与0x1做与操作确保只返回0或1
	 */
	int ans = (~(h1 ^ h2)) & 0x1;
	return ans;
}

/********************************************************************************/
/*
 * addOK - 判断是否可以计算x+y而不发生溢出
 * 中文题目：判断是否可以安全地计算x+y而不会发生整数溢出
 * 示例：addOK(0x80000000,0x80000000) = 0（两个负数相加溢出）
 *      addOK(0x80000000,0x70000000) = 1（不会溢出）
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：20
 * 难度评级：3
 */
int addOK(int x, int y) {
	/* 
	 * 先计算x+y的和
	 */
	int sum = x + y;
	/* 
	 * 检查x和y是否符号相同
	 * 如果x和y符号相同，x^y的最高位为0，取反后为1
	 */
	int same_sig_bits = ~(x ^ y);
	/* 
	 * 检查x和sum的符号是否不同
	 * 如果x和sum符号不同，x^sum的最高位为1
	 */
	int diff_sig_sum = (x ^ sum);
	/* 
	 * 当且仅当x和y符号相同，且x和sum符号不同时，发生溢出
	 * 此时(same_sig_bits & diff_sig_sum)的最高位为1
	 * 右移31位提取最高位，再取反得到0表示溢出，1表示无溢出
	 */
	return !((same_sig_bits & diff_sig_sum) >> 31);
}

/*
 * ezThreeFourths - 计算x乘以3/4，向零舍入
 * 中文题目：计算x乘以3/4，结果向零舍入，需要完全复制C表达式(x*3/4)的效果，包括溢出行为
 * 示例：ezThreeFourths(11) = 8
 *      ezThreeFourths(-9) = -6
 *      ezThreeFourths(1073741824) = -268435456（发生溢出）
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：12
 * 难度评级：3
 */
int ezThreeFourths(int x) {
	/* 
	 * 计算x*3：左移1位相当于乘以2，再加上x相当于乘以3
	 */
	int x3 = (x << 1) + x;
	/* 
	 * 获取x*3的符号位
	 * 如果x3为负数，sign为全1（-1的补码表示），否则为0
	 */
	int sign = x3 >> 31;
	/* 
	 * 计算偏置值：对于负数，需要加3进行向上舍入以实现向零舍入
	 * sign & 3：如果是负数则为3，否则为0
	 */
	int bias = sign & 3;
	/* 
	 * 加上偏置值后右移2位，相当于除以4
	 * 这确保了向零舍入的正确性
	 */
	return (x3 + bias) >> 2;
}

/*
 * isGreater - 判断x是否大于y，如果x > y则返回1，否则返回0
 * 中文题目：实现比较函数，如果x大于y则返回1，否则返回0
 * 示例：isGreater(4,5) = 0, isGreater(5,4) = 1
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：24
 * 难度评级：3
 */

int isGreater(int x, int y) {
	/* 
	 * 获取x的符号位，sx=1表示x为负数，sx=0表示x为非负数
	 */
	int sx = (x >> 31) & 0x1;
	/* 
	 * 获取y的符号位，sy=1表示y为负数，sy=0表示y为非负数
	 */
	int sy = (y >> 31) & 0x1;
	/* 
	 * 判断x和y是否符号不同
	 * diff_sign=1表示x和y符号不同
	 */
	int diff_sign = sx ^ sy;
	/* 
	 * 当x和y符号不同时，如果x为非负数且y为负数，则x > y
	 */
	int is_diff_sign_greater = (!sx) & sy;
	/* 
	 * 计算x - y：使用补码加法，~y + 1等于-y
	 */
	int z = x + (~y) + 1;
	/* 
	 * 获取x - y的符号位
	 * z_sign=0表示x - y为非负数
	 */
	int z_sign = (z >> 31) & 0x1;
	/* 
	 * 判断x - y是否非零
	 * !!z将z转换为逻辑值（0或1）
	 */
	int z_is_non_zero = !!z;
	/* 
	 * 当x和y符号相同时，如果x - y为正数且非零，则x > y
	 */
	int is_same_sign_greater = (!diff_sign) & (!z_sign) & z_is_non_zero;
	/* 
	 * 综合两种情况：符号不同时的判断结果 或 符号相同时的判断结果
	 */
	return is_diff_sign_greater | is_same_sign_greater;
}

/*
 * logicalShift - 对x进行逻辑右移n位
 * 中文题目：实现逻辑右移操作，将x向右移动n位，高位填充0
 * 可以假设0 <= n <= 31
 * 示例：logicalShift(0x87654321,4) = 0x08765432
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：20
 * 难度评级：3
 */

int logicalShift(int x, int n) {
	/* 
	 * 首先进行算术右移（在C语言中，有符号整数的>>是算术右移）
	 * 然后使用掩码清除可能被符号位填充的高位
	 */
	/* 
	 * 创建一个掩码：
	 * ~(1 << 31) 是一个符号位为0，其余位为1的数
	 * 右移n位后，得到一个前n位为0，后面位为1的数
	 * 再左移1位并或1，确保最低位为1
	 */
	return (x >> n) & ((((~(1 << 31)) >> n) << 1) | 1);
}

/*
 * replaceByte(x,n,c) - 用字节c替换x中的第n个字节
 * 中文题目：将32位整数x中的第n个字节替换为c
 * 字节编号规则：从0（最低有效字节）到3（最高有效字节）
 * 示例：replaceByte(0x12345678,1,0xab) = 0x1234ab78（将第二个字节0x56替换为0xab）
 * 可以假设0 <= n <= 3 且 0 <= c <= 255
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：10
 * 难度评级：3
 */

int replaceByte(int x, int n, int c) {
	/* 
	 * 计算需要左移的位数，每个字节占8位，所以n << 3相当于n * 8
	 */
	int shift = n << 3;
	/* 
	 * 创建一个掩码，将0xFF左移shift位，用于定位目标字节
	 */
	int byte_mask = 0xFF << shift;
	/* 
	 * 创建清除掩码，用于清除x中的目标字节位
	 */
	int clear_mask = ~byte_mask;
	/* 
	 * 使用清除掩码将x中的目标字节置为0
	 */
	int x_cleared = x & clear_mask;
	/* 
	 * 将c左移到目标字节位置
	 */
	int c_shifted = c << shift;
	/* 
	 * 使用或操作将c的字节插入到x中
	 */
	return x_cleared | c_shifted;
}

/*
 * rotateRight - 将x向右循环移位n位
 * 中文题目：实现循环右移操作，将x向右循环移动n位
 * 可以假设0 <= n <= 31
 * 示例：rotateRight(0x87654321,4) = 0x18765432（最右边的4位移到左边）
 * 允许的操作：~ & ^ | + << >> !
 * 最大操作数：25
 * 难度评级：3
 */

int rotateRight(int x, int n) {
	/* 
	 * 计算左移的位数：32 - n
	 * 使用32 + (~n + 1) 来避免使用减法操作符
	 */
	int left = 32 + (~n + 1);
	/* 
	 * 将x左移left位，将右侧的n位移到左侧
	 * 这部分是要循环到左侧的位
	 */
	int wrap = x << left;
	/* 
	 * 对x进行右移n位
	 */
	int right = x >> n;
	/* 
	 * 创建掩码，用于清除右移后可能出现的符号扩展位
	 */
	int mask = ~0 << left;
	/* 
	 * 使用掩码确保right是逻辑右移的结果
	 */
	int log_right = right & (~mask);
	/* 
	 * 组合循环移位的两部分：右侧的移位结果和左侧的循环部分
	 */
	return log_right | wrap;
}

/********************************************************************************/
/*
 * float_i2f - 返回表达式(float)x的位级表示
 * 中文题目：将32位有符号整数x转换为对应的IEEE单精度浮点数的位级表示
 * 结果以无符号整数形式返回，但应被解释为单精度浮点数的位级表示
 * 允许的操作：任何整数/无符号操作，包括||, &&，以及if, while
 * 最大操作数：30
 * 难度评级：4
 */

unsigned float_i2f(int x) {
	/* 
	 * 提取符号位：1表示负数，0表示非负数
	 */
	int sign = x & (1 << 31);
	/* 
	 * 定义最小值（最负的数）
	 */
	int minus = 1 << 31;
	/* 
	 * 初始化指数为31（假设最高有效位在第31位）
	 */
	int exp = 31;
	/* 
	 * IEEE单精度浮点数的指数偏置
	 */
	int bias = 127;
	/* 
	 * 存储尾数部分
	 */
	int frac;
	/* 
	 * 特殊情况：如果x为0，直接返回0
	 */
	if (!x)
		return 0;
	/* 
	 * 特殊情况：如果x是最小的负数（-2^31），直接构造结果
	 */
	if (x == minus)
		return minus | ((exp + bias) << 23);
	/* 
	 * 如果x为负数，先取其绝对值（转换为正数）
	 */
	if (sign)
		x = ~x + 1;
	/* 
	 * 找到最高有效位的位置，调整x和指数
	 */
	while (!(x & minus))
	{
		x <<= 1; // 左移直到最高位为1
		exp -= 1; // 调整指数
	}
	/* 
	 * 提取23位尾数：清除符号位后的x右移8位（31-23=8）
	 */
	frac = (((~minus) & x) >> 8);
	
	/* 
	 * 处理舍入：如果剩余位需要舍入（超过0.5）
	 * 检查第8位是否为1，并且第0-7位不全为0或frac最低位为1（银行家舍入）
	 */
	if (x & 0x80 && ((frac & 1) || ((x & 0x7f) > 0)))
		frac++;
	/* 
	 * 组合符号位、指数部分和尾数部分
	 */
	return sign + ((exp + bias) << 23) + frac;
}

/* 
 * howManyBits - 返回在补码表示法中表示x所需的最小位数
 * 中文题目：计算在补码表示法中表示整数x所需的最小位数
 * 示例：howManyBits(12) = 5（12的二进制是1100，加上符号位共5位）
 *      howManyBits(298) = 10
 *      howManyBits(-5) = 4（-5的4位补码表示为1011）
 *      howManyBits(0)  = 1
 *      howManyBits(-1) = 1（-1在任何位数的补码中都是全1）
 *      howManyBits(0x80000000) = 32
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：90
 * 难度评级：4
 */

int howManyBits(int x) {
	/* 
	 * 生成一个模式，使得第一个不同的位就是符号扩展开始的位置
	 * x ^ (x << 1) 会在x的最高有效位变化的位置产生1
	 */
	int temp = x ^ (x << 1);
	/* 
	 * 用于存储各次二分查找的结果
	 */
	int bit_16, bit_8, bit_4, bit_2, bit_1;
	/* 
	 * 二分查找算法：从高位到低位查找最高位的1
	 * 先检查高16位是否有1
	 */
	bit_16 = !!(temp >> 16) << 4; // 如果高16位有1，bit_16=16，否则=0
	temp = temp >> bit_16; // 如果高16位有1，右移16位继续查找
	/* 
	 * 检查接下来的8位是否有1
	 */
	bit_8 = !!(temp >> 8) << 3; // 如果接下来的8位有1，bit_8=8，否则=0
	temp = temp >> bit_8; // 右移相应位数
	/* 
	 * 检查接下来的4位是否有1
	 */
	bit_4 = !!(temp >> 4) << 2; // 如果接下来的4位有1，bit_4=4，否则=0
	temp = temp >> bit_4; // 右移相应位数
	/* 
	 * 检查接下来的2位是否有1
	 */
	bit_2 = !!(temp >> 2) << 1; // 如果接下来的2位有1，bit_2=2，否则=0
	temp = temp >> bit_2; // 右移相应位数
	/* 
	 * 检查最后1位
	 */
	bit_1 = !!(temp >> 1); // 如果最后1位有1，bit_1=1，否则=0
	/* 
	 * 总数加1是因为需要包含符号位
	 */
	return 1 + bit_1 + bit_2 + bit_4 + bit_8 + bit_16;
}

/*
 * parityCheck - 如果x中包含奇数个1，则返回1
 * 中文题目：计算x的奇偶校验位，如果x的二进制表示中1的个数为奇数，则返回1，否则返回0
 * 示例：parityCheck(5) = 0（5的二进制是101，有2个1，偶数）
 *      parityCheck(7) = 1（7的二进制是111，有3个1，奇数）
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：20
 * 难度评级：4
 */

int parityCheck(int x) {
	/* 
	 * 使用分治法，通过异或操作逐步减少需要检查的位数
	 * 先将x与右移16位的x异或，得到的结果中每一位代表原始x中对应位置及其右侧16位的异或结果
	 */
	x ^= (x >> 16);
	/* 
	 * 再将结果与右移8位的自身异或
	 */
	x ^= (x >> 8);
	/* 
	 * 继续右移4位异或
	 */
	x ^= (x >> 4);
	/* 
	 * 继续右移2位异或
	 */
	x ^= (x >> 2);
	/* 
	 * 最后右移1位异或
	 */
	x ^= (x >> 1);
	/* 
	 * 此时最低位包含了所有位的异或结果，即奇偶校验位
	 */
	return x & 1;
}

/*
 * trueThreeFourths - 计算x乘以3/4，向零舍入，避免溢出错误
 * 中文题目：计算x乘以3/4，结果向零舍入，且避免中间计算过程中的溢出
 * 示例：trueThreeFourths(11) = 8
 *      trueThreeFourths(-9) = -6
 *      trueThreeFourths(1073741824) = 805306368（无溢出）
 * 允许的操作：! ~ & ^ | + << >>
 * 最大操作数：20
 * 难度评级：4
 */

int trueThreeFourths(int x)
{
	/* 
	 * 将x分为两部分处理：
	 * x1 = x / 4（整数除法，向零舍入）
	 */
	int x1 = x >> 2;
	/* 
	 * x2 = x % 4（获取x除以4的余数）
	 */
	int x2 = x & 3;
	/* 
	 * 计算(x/4) * 3
	 * 使用x1 + x1 + x1 而不是 x1 * 3，避免乘法操作符
	 */
	int ans1 = (x1 + x1 + x1);
	/* 
	 * 获取x的符号位，并将其扩展为2位
	 * 对于负数，sgn=3（二进制11），用于正确舍入
	 */
	int sgn = (x >> 31) & 3;
	/* 
	 * 计算(x % 4) * 3 / 4
	 * 加上sgn进行正确的舍入（对于负数需要调整）
	 */
	int ans2 = (x2 + x2 + x2 + sgn) >> 2;
	/* 
	 * 将两部分结果相加得到最终结果
	 * 这种方法避免了直接计算x*3可能导致的溢出
	 */
	return ans1 + ans2;
}